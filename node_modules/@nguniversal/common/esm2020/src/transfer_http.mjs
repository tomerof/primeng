/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { HTTP_INTERCEPTORS, HttpHeaders, HttpResponse, } from '@angular/common/http';
import { ApplicationRef, Injectable, NgModule } from '@angular/core';
import { TransferState, makeStateKey } from '@angular/platform-browser';
import { of as observableOf } from 'rxjs';
import { defaultIfEmpty, first, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/platform-browser";
function getHeadersMap(headers) {
    const headersMap = {};
    for (const key of headers.keys()) {
        const values = headers.getAll(key);
        if (values !== null) {
            headersMap[key] = values;
        }
    }
    return headersMap;
}
export class TransferHttpCacheInterceptor {
    makeCacheKey(method, url, params, responseType) {
        // make the params encoded same as a url so it's easy to identify
        const encodedParams = params
            .keys()
            .sort()
            .map((k) => `${k}=${params.getAll(k)}`)
            .join('&');
        const key = (method === 'GET' ? 'G.' : 'H.') + responseType + '.' + url + '?' + encodedParams;
        return makeStateKey(key);
    }
    constructor(appRef, transferState) {
        this.transferState = transferState;
        this.isCacheActive = true;
        // Stop using the cache if the application has stabilized, indicating initial rendering is
        // complete.
        appRef.isStable
            .pipe(first((isStable) => isStable), defaultIfEmpty(false))
            .subscribe(() => {
            this.isCacheActive = false;
        });
    }
    intercept(req, next) {
        if (!this.isCacheActive || (req.method !== 'GET' && req.method !== 'HEAD')) {
            // Cache is no longer active or method is not HEAD or GET.
            // Pass the request through.
            return next.handle(req);
        }
        const storeKey = this.makeCacheKey(req.method, req.url, req.params, req.responseType);
        if (this.transferState.hasKey(storeKey)) {
            // Request found in cache. Respond using it.
            const response = this.transferState.get(storeKey, {});
            let body = response.body;
            switch (response.responseType) {
                case 'arraybuffer':
                    body = new TextEncoder().encode(response.body).buffer;
                    break;
                case 'blob':
                    body = new Blob([response.body]);
                    break;
            }
            return observableOf(new HttpResponse({
                body,
                headers: new HttpHeaders(response.headers),
                status: response.status,
                statusText: response.statusText,
                url: response.url,
            }));
        }
        else {
            // Request not found in cache. Make the request and cache it.
            const httpEvent = next.handle(req);
            return httpEvent.pipe(tap((event) => {
                if (event instanceof HttpResponse) {
                    this.transferState.set(storeKey, {
                        body: event.body,
                        headers: getHeadersMap(event.headers),
                        status: event.status,
                        statusText: event.statusText,
                        url: event.url || '',
                        responseType: req.responseType,
                    });
                }
            }));
        }
    }
}
TransferHttpCacheInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.0", ngImport: i0, type: TransferHttpCacheInterceptor, deps: [{ token: i0.ApplicationRef }, { token: i1.TransferState }], target: i0.ɵɵFactoryTarget.Injectable });
TransferHttpCacheInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.0", ngImport: i0, type: TransferHttpCacheInterceptor });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.0", ngImport: i0, type: TransferHttpCacheInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ApplicationRef }, { type: i1.TransferState }]; } });
/**
 * An NgModule used in conjunction with `ServerTransferHttpCacheModule` to transfer cached HTTP
 * calls from the server to the client application.
 */
export class TransferHttpCacheModule {
}
TransferHttpCacheModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.0", ngImport: i0, type: TransferHttpCacheModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TransferHttpCacheModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.2.0", ngImport: i0, type: TransferHttpCacheModule });
TransferHttpCacheModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.2.0", ngImport: i0, type: TransferHttpCacheModule, providers: [
        ApplicationRef,
        TransferState,
        TransferHttpCacheInterceptor,
        { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.0", ngImport: i0, type: TransferHttpCacheModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        ApplicationRef,
                        TransferState,
                        TransferHttpCacheInterceptor,
                        { provide: HTTP_INTERCEPTORS, useExisting: TransferHttpCacheInterceptor, multi: true },
                    ],
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJfaHR0cC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL21vZHVsZXMvY29tbW9uL3NyYy90cmFuc2Zlcl9odHRwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFDTCxpQkFBaUIsRUFHakIsV0FBVyxFQUlYLFlBQVksR0FDYixNQUFNLHNCQUFzQixDQUFDO0FBQzlCLE9BQU8sRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRSxPQUFPLEVBQVksYUFBYSxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ2xGLE9BQU8sRUFBYyxFQUFFLElBQUksWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFhNUQsU0FBUyxhQUFhLENBQUMsT0FBb0I7SUFDekMsTUFBTSxVQUFVLEdBQTZCLEVBQUUsQ0FBQztJQUNoRCxLQUFLLE1BQU0sR0FBRyxJQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNoQyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ25DLElBQUksTUFBTSxLQUFLLElBQUksRUFBRTtZQUNuQixVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDO1NBQzFCO0tBQ0Y7SUFFRCxPQUFPLFVBQVUsQ0FBQztBQUNwQixDQUFDO0FBR0QsTUFBTSxPQUFPLDRCQUE0QjtJQUcvQixZQUFZLENBQ2xCLE1BQWMsRUFDZCxHQUFXLEVBQ1gsTUFBa0IsRUFDbEIsWUFBMEI7UUFFMUIsaUVBQWlFO1FBQ2pFLE1BQU0sYUFBYSxHQUFHLE1BQU07YUFDekIsSUFBSSxFQUFFO2FBQ04sSUFBSSxFQUFFO2FBQ04sR0FBRyxDQUFDLENB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dUIsUUFBUSxFQUFFO3dCQUNyRCxJQUFJLEVBQUUsS0FBSyxDQUFDLElBQUk7d0JBQ2hCLE9BQU8sRUFBRSxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQzt3QkFDckMsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNO3dCQUNwQixVQUFVLEVBQUUsS0FBSyxDQUFDLFVBQVU7d0JBQzVCLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRyxJQUFJLEVBQUU7d0JBQ3BCLFlBQVksRUFBRSxHQUFHLENBQUMsWUFBWTtxQkFDL0IsQ0FBQyxDQUFDO2lCQUNKO1lBQ0gsQ0FBQyxDQUFDLENBQ0gsQ0FBQztTQUNIO0lBQ0gsQ0FBQzs7eUhBckZVLDRCQUE0Qjs2SEFBNUIsNEJBQTRCOzJGQUE1Qiw0QkFBNEI7a0JBRHhDLFVBQVU7O0FBeUZYOzs7R0FHRztBQVNILE1BQU0sT0FBTyx1QkFBdUI7O29IQUF2Qix1QkFBdUI7cUhBQXZCLHVCQUF1QjtxSEFBdkIsdUJBQXVCLGFBUHZCO1FBQ1QsY0FBYztRQUNkLGFBQWE7UUFDYiw0QkFBNEI7UUFDNUIsRUFBRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLDRCQUE0QixFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUU7S0FDdkY7MkZBRVUsdUJBQXVCO2tCQVJuQyxRQUFRO21CQUFDO29CQUNSLFNBQVMsRUFBRTt3QkFDVCxjQUFjO3dCQUNkLGFBQWE7d0JBQ2IsNEJBQTRCO3dCQUM1QixFQUFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsNEJBQTRCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRTtxQkFDdkY7aUJBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtcbiAgSFRUUF9JTlRFUkNFUFRPUlMsXG4gIEh0dHBFdmVudCxcbiAgSHR0cEhhbmRsZXIsXG4gIEh0dHBIZWFkZXJzLFxuICBIdHRwSW50ZXJjZXB0b3IsXG4gIEh0dHBQYXJhbXMsXG4gIEh0dHBSZXF1ZXN0LFxuICBIdHRwUmVzcG9uc2UsXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uUmVmLCBJbmplY3RhYmxlLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3RhdGVLZXksIFRyYW5zZmVyU3RhdGUsIG1ha2VTdGF0ZUtleSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgYXMgb2JzZXJ2YWJsZU9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWZhdWx0SWZFbXB0eSwgZmlyc3QsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxudHlwZSBSZXNwb25zZVR5cGUgPSBIdHRwUmVxdWVzdDx1bmtub3duPlsncmVzcG9uc2VUeXBlJ107XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNmZXJIdHRwUmVzcG9uc2Uge1xuICBib2R5PzogYW55IHwgbnVsbDtcbiAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPjtcbiAgc3RhdHVzPzogbnVtYmVyO1xuICBzdGF0dXNUZXh0Pzogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG4gIHJlc3BvbnNlVHlwZT86IFJlc3BvbnNlVHlwZTtcbn1cblxuZnVuY3Rpb24gZ2V0SGVhZGVyc01hcChoZWFkZXJzOiBIdHRwSGVhZGVycyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiB7XG4gIGNvbnN0IGhlYWRlcnNNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBoZWFkZXJzLmtleXMoKSkge1xuICAgIGNvbnN0IHZhbHVlcyA9IGhlYWRlcnMuZ2V0QWxsKGtleSk7XG4gICAgaWYgKHZhbHVlcyAhPT0gbnVsbCkge1xuICAgICAgaGVhZGVyc01hcFtrZXldID0gdmFsdWVzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzTWFwO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJhbnNmZXJIdHRwQ2FjaGVJbnRlcmNlcHRvciBpbXBsZW1lbnRzIEh0dHBJbnRlcmNlcHRvciB7XG4gIHByaXZhdGUgaXNDYWNoZUFjdGl2ZSA9IHRydWU7XG5cbiAgcHJpdmF0ZSBtYWtlQ2FjaGVLZXkoXG4gICAgbWV0aG9kOiBzdHJpbmcsXG4gICAgdXJsOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBIdHRwUGFyYW1zLFxuICAgIHJlc3BvbnNlVHlwZTogUmVzcG9uc2VUeXBlLFxuICApOiBTdGF0ZUtleTxUcmFuc2Zlckh0dHBSZXNwb25zZT4ge1xuICAgIC8vIG1ha2UgdGhlIHBhcmFtcyBlbmNvZGVkIHNhbWUgYXMgYSB1cmwgc28gaXQncyBlYXN5IHRvIGlkZW50aWZ5XG4gICAgY29uc3QgZW5jb2RlZFBhcmFtcyA9IHBhcmFtc1xuICAgICAgLmtleXMoKVxuICAgICAgLnNvcnQoKVxuICAgICAgLm1hcCgoaykgPT4gYCR7a309JHtwYXJhbXMuZ2V0QWxsKGspfWApXG4gICAgICAuam9pbignJicpO1xuXG4gICAgY29uc3Qga2V5ID0gKG1ldGhvZCA9PT0gJ0dFVCcgPyAnRy4nIDogJ0guJykgKyByZXNwb25zZVR5cGUgKyAnLicgKyB1cmwgKyAnPycgKyBlbmNvZGVkUGFyYW1zO1xuXG4gICAgcmV0dXJuIG1ha2VTdGF0ZUtleTxUcmFuc2Zlckh0dHBSZXNwb25zZT4oa2V5KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFwcFJlZjogQXBwbGljYXRpb25SZWYsIHByaXZhdGUgdHJhbnNmZXJTdGF0ZTogVHJhbnNmZXJTdGF0ZSkge1xuICAgIC8vIFN0b3AgdXNpbmcgdGhlIGNhY2hlIGlmIHRoZSBhcHBsaWNhdGlvbiBoYXMgc3RhYmlsaXplZCwgaW5kaWNhdGluZyBpbml0aWFsIHJlbmRlcmluZyBpc1xuICAgIC8vIGNvbXBsZXRlLlxuICAgIGFwcFJlZi5pc1N0YWJsZVxuICAgICAgLnBpcGUoXG4gICAgICAgIGZpcnN0KChpc1N0YWJsZSkgPT4gaXNTdGFibGUpLFxuICAgICAgICBkZWZhdWx0SWZFbXB0eShmYWxzZSksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5pc0NhY2hlQWN0aXZlID0gZmFsc2U7XG4gICAgICB9KTtcbiAgfVxuXG4gIGludGVyY2VwdChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuICAgIGlmICghdGhpcy5pc0NhY2hlQWN0aXZlIHx8IChyZXEubWV0aG9kICE9PSAnR0VUJyAmJiByZXEubWV0aG9kICE9PSAnSEVBRCcpKSB7XG4gICAgICAvLyBDYWNoZSBpcyBubyBsb25nZXIgYWN0aXZlIG9yIG1ldGhvZCBpcyBub3QgSEVBRCBvciBHRVQuXG4gICAgICAvLyBQYXNzIHRoZSByZXF1ZXN0IHRocm91Z2guXG4gICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZUtleSA9IHRoaXMubWFrZUNhY2hlS2V5KHJlcS5tZXRob2QsIHJlcS51cmwsIHJlcS5wYXJhbXMsIHJlcS5yZXNwb25zZVR5cGUpO1xuXG4gICAgaWYgKHRoaXMudHJhbnNmZXJTdGF0ZS5oYXNLZXkoc3RvcmVLZXkpKSB7XG4gICAgICAvLyBSZXF1ZXN0IGZvdW5kIGluIGNhY2hlLiBSZXNwb25kIHVzaW5nIGl0LlxuICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnRyYW5zZmVyU3RhdGUuZ2V0KHN0b3JlS2V5LCB7fSk7XG4gICAgICBsZXQgYm9keTogQXJyYXlCdWZmZXIgfCBCbG9iIHwgc3RyaW5nIHwgdW5kZWZpbmVkID0gcmVzcG9uc2UuYm9keTtcblxuICAgICAgc3dpdGNoIChyZXNwb25zZS5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgY2FzZSAnYXJyYXlidWZmZXInOlxuICAgICAgICAgIGJvZHkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocmVzcG9uc2UuYm9keSkuYnVmZmVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibG9iJzpcbiAgICAgICAgICBib2R5ID0gbmV3IEJsb2IoW3Jlc3BvbnNlLmJvZHldKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ic2VydmFibGVPZihcbiAgICAgICAgbmV3IEh0dHBSZXNwb25zZTxhbnk+KHtcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGhlYWRlcnM6IG5ldyBIdHRwSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKSxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcXVlc3Qgbm90IGZvdW5kIGluIGNhY2hlLiBNYWtlIHRoZSByZXF1ZXN0IGFuZCBjYWNoZSBpdC5cbiAgICAgIGNvbnN0IGh0dHBFdmVudCA9IG5leHQuaGFuZGxlKHJlcSk7XG5cbiAgICAgIHJldHVybiBodHRwRXZlbnQucGlwZShcbiAgICAgICAgdGFwKChldmVudDogSHR0cEV2ZW50PHVua25vd24+KSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZmVyU3RhdGUuc2V0PFRyYW5zZmVySHR0cFJlc3BvbnNlPihzdG9yZUtleSwge1xuICAgICAgICAgICAgICBib2R5OiBldmVudC5ib2R5LFxuICAgICAgICAgICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzTWFwKGV2ZW50LmhlYWRlcnMpLFxuICAgICAgICAgICAgICBzdGF0dXM6IGV2ZW50LnN0YXR1cyxcbiAgICAgICAgICAgICAgc3RhdHVzVGV4dDogZXZlbnQuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgdXJsOiBldmVudC51cmwgfHwgJycsXG4gICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogcmVxLnJlc3BvbnNlVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIE5nTW9kdWxlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgU2VydmVyVHJhbnNmZXJIdHRwQ2FjaGVNb2R1bGVgIHRvIHRyYW5zZmVyIGNhY2hlZCBIVFRQXG4gKiBjYWxscyBmcm9tIHRoZSBzZXJ2ZXIgdG8gdGhlIGNsaWVudCBhcHBsaWNhdGlvbi5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgcHJvdmlkZXJzOiBbXG4gICAgQXBwbGljYXRpb25SZWYsXG4gICAgVHJhbnNmZXJTdGF0ZSxcbiAgICBUcmFuc2Zlckh0dHBDYWNoZUludGVyY2VwdG9yLFxuICAgIHsgcHJvdmlkZTogSFRUUF9JTlRFUkNFUFRPUlMsIHVzZUV4aXN0aW5nOiBUcmFuc2Zlckh0dHBDYWNoZUludGVyY2VwdG9yLCBtdWx0aTogdHJ1ZSB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBUcmFuc2Zlckh0dHBDYWNoZU1vZHVsZSB7fVxuIl19