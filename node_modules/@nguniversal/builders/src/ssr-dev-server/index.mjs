/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { createBuilder, targetFromTargetString, } from '@angular-devkit/architect';
import { tags } from '@angular-devkit/core';
import * as browserSync from 'browser-sync';
import { createProxyMiddleware } from 'http-proxy-middleware';
import { join, resolve as pathResolve } from 'path';
import { EMPTY, combineLatest, from, of, zip } from 'rxjs';
import { catchError, concatMap, debounce, debounceTime, delay, finalize, ignoreElements, map, mapTo, startWith, switchMap, tap, } from 'rxjs/operators';
import * as url from 'url';
import { getAvailablePort, spawnAsObservable, waitUntilServerIsListening } from './utils';
/** Log messages to ignore and not rely to the logger */
const IGNORED_STDOUT_MESSAGES = [
    'server listening on',
    'Angular is running in development mode. Call enableProdMode() to enable production mode.',
];
export function execute(options, context) {
    const browserTarget = targetFromTargetString(options.browserTarget);
    const serverTarget = targetFromTargetString(options.serverTarget);
    const getBaseUrl = (bs) => `${bs.getOption('scheme')}://${bs.getOption('host')}:${bs.getOption('port')}`;
    const browserTargetRun = context.scheduleTarget(browserTarget, {
        serviceWorker: false,
        watch: true,
        progress: options.progress,
        verbose: options.verbose,
        // Disable bundle budgets are these are not meant to be used with a dev-server as this will add extra JavaScript for live-reloading.
        budgets: [],
    });
    const serverTargetRun = context.scheduleTarget(serverTarget, {
        watch: true,
        progress: options.progress,
        verbose: options.verbose,
    });
    const bsInstance = browserSync.create();
    context.logger.error(tags.stripIndents `
  ****************************************************************************************
  This is a simple server for use in testing or debugging Angular applications locally.
  It hasn't been reviewed for security issues.

  DON'T USE IT FOR PRODUCTION!
  ****************************************************************************************
 `);
    return zip(browserTargetRun, serverTargetRun, getAvailablePort()).pipe(switchMap(([br, sr, nodeServerPort]) => {
        return combineLatest([br.output, sr.output]).pipe(
        // This is needed so that if both server and browser emit close to each other
        // we only emit once. This typically happens on the first build.
        debounceTime(120), switchMap(([b, s]) => {
            if (!s.success || !b.success) {
                return of([b, s]);
            }
            return startNodeServer(s, nodeServerPort, context.logger, !!options.inspect).pipe(mapTo([b, s]), catchError((err) => {
                context.logger.error(`A server error has occurred.\n${mapErrorToMessage(err)}`);
                return EMPTY;
            }));
        }), map(([b, s]) => [
            {
                success: b.success && s.success,
                error: b.error || s.error,
            },
            nodeServerPort,
        ]), tap(([builderOutput]) => {
            if (builderOutput.success) {
                context.logger.info('\nCompiled successfully.');
            }
        }), debounce(([builderOutput]) => builderOutput.success && !options.inspect
            ? waitUntilServerIsListening(nodeServerPort)
            : EMPTY), finalize(() => {
            void br.stop();
            void sr.stop();
        }));
    }), concatMap(([builderOutput, nodeServerPort]) => {
        if (!builderOutput.success) {
            return of(builderOutput);
        }
        if (bsInstance.active) {
            bsInstance.reload();
            return of(builderOutput);
        }
        else {
            return from(initBrowserSync(bsInstance, nodeServerPort, options, context)).pipe(tap((bs) => {
                const baseUrl = getBaseUrl(bs);
                context.logger.info(tags.oneLine `
                **
                Angular Universal Live Development Server is listening on ${baseUrl},
                open your browser on ${baseUrl}
                **
              `);
            }), mapTo(builderOutput));
        }
    }), map((builderOutput) => ({
        success: builderOutput.success,
        error: builderOutput.error,
        baseUrl: bsInstance && getBaseUrl(bsInstance),
    })), finalize(() => {
        if (bsInstance) {
            bsInstance.exit();
            bsInstance.cleanup();
        }
    }), catchError((error) => of({
        success: false,
        error: mapErrorToMessage(error),
    })));
}
function startNodeServer(serverOutput, port, logger, inspectMode = false) {
    const outputPath = serverOutput.outputPath;
    const path = join(outputPath, 'main.js');
    const env = Object.assign(Object.assign({}, process.env), { PORT: '' + port });
    const args = ['--enable-source-maps', `"${path}"`];
    if (inspectMode) {
        args.unshift('--inspect-brk');
    }
    return of(null).pipe(delay(0), // Avoid EADDRINUSE error since it will cause the kill event to be finish.
    switchMap(() => spawnAsObservable('node', args, { env, shell: true })), tap(({ stderr, stdout }) => {
        if (stderr) {
            // Strip the webpack scheme (webpack://) from error log.
            logger.error(stderr.replace(/webpack:\/\//g, '.'));
        }
        if (stdout && !IGNORED_STDOUT_MESSAGES.some((x) => stdout.includes(x))) {
            logger.info(stdout);
        }
    }), ignoreElements(), 
    // Emit a signal after the process has been started
    startWith(undefined));
}
function initBrowserSync(browserSyncInstance, nodeServerPort, options, context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (browserSyncInstance.active) {
            return browserSyncInstance;
        }
        const { port: browserSyncPort, open, host, publicHost, proxyConfig } = options;
        const bsPort = browserSyncPort || (yield getAvailablePort());
        const bsOptions = {
            proxy: {
                target: `localhost:${nodeServerPort}`,
                proxyOptions: {
                    xfwd: true,
                },
                proxyRes: [
                    (proxyRes) => {
                        if ('headers' in proxyRes) {
                            proxyRes.headers['cache-control'] = undefined;
                        }
                    },
                ],
                // proxyOptions is not in the typings
            },
            host,
            port: bsPort,
            ui: false,
            server: false,
            notify: false,
            ghostMode: false,
            logLevel: options.verbose ? 'debug' : 'silent',
            open,
            https: getSslConfig(context.workspaceRoot, options),
        };
        const publicHostNormalized = publicHost && publicHost.endsWith('/')
            ? publicHost.substring(0, publicHost.length - 1)
            : publicHost;
        if (publicHostNormalized) {
            const { protocol, hostname, port, pathname } = url.parse(publicHostNormalized);
            const defaultSocketIoPath = '/browser-sync/socket.io';
            const defaultNamespace = '/browser-sync';
            const hasPathname = !!(pathname && pathname !== '/');
            const namespace = hasPathname ? pathname + defaultNamespace : defaultNamespace;
            const path = hasPathname ? pathname + defaultSocketIoPath : defaultSocketIoPath;
            bsOptions.socket = {
                namespace,
                path,
                domain: url.format({
                    protocol,
                    hostname,
                    port,
                }),
            };
            // When having a pathname we also need to create a reverse proxy because socket.io
            // will be listening on: 'http://localhost:4200/ssr/browser-sync/socket.io'
            // However users will typically have a reverse proxy that will redirect all matching requests
            // ex: http://testinghost.com/ssr -> http://localhost:4200 which will result in a 404.
            if (hasPathname) {
                // Remove leading slash
                // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                (bsOptions.scriptPath = (p) => p.substring(1)),
                    (bsOptions.middleware = [
                        createProxyMiddleware(defaultSocketIoPath, {
                            target: url.format({
                                protocol: 'http',
                                hostname: host,
                                port: bsPort,
                                pathname: path,
                            }),
                            ws: true,
                            logLevel: 'silent',
                        }),
                    ]);
            }
        }
        if (proxyConfig) {
            if (!bsOptions.middleware) {
                bsOptions.middleware = [];
            }
            else if (!Array.isArray(bsOptions.middleware)) {
                bsOptions.middleware = [bsOptions.middleware];
            }
            bsOptions.middleware = [
                ...bsOptions.middleware,
                ...getProxyConfig(context.workspaceRoot, proxyConfig),
            ];
        }
        return new Promise((resolve, reject) => {
            browserSyncInstance.init(bsOptions, (error, bs) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(bs);
                }
            });
        });
    });
}
function mapErrorToMessage(error) {
    if (error instanceof Error) {
        return error.message;
    }
    if (typeof error === 'string') {
        return error;
    }
    return '';
}
function getSslConfig(root, options) {
    const { ssl, sslCert, sslKey } = options;
    if (ssl && sslCert && sslKey) {
        return {
            key: pathResolve(root, sslKey),
            cert: pathResolve(root, sslCert),
        };
    }
    return ssl;
}
function getProxyConfig(root, proxyConfig) {
    const proxyPath = pathResolve(root, proxyConfig);
    let proxySettings;
    try {
        proxySettings = require(proxyPath);
    }
    catch (error) {
        if (error.code === 'MODULE_NOT_FOUND') {
            throw new Error(`Proxy config file ${proxyPath} does not exist.`);
        }
        throw error;
    }
    const proxies = Array.isArray(proxySettings) ? proxySettings : [proxySettings];
    const createdProxies = [];
    for (const proxy of proxies) {
        for (const [key, context] of Object.entries(proxy)) {
            if (typeof key === 'string') {
                createdProxies.push(createProxyMiddleware(key.replace(/^\*$/, '**').replace(/\/\*$/, ''), context));
            }
            else {
                createdProxies.push(createProxyMiddleware(key, context));
            }
        }
    }
    return createdProxies;
}
export default createBuilder(execute);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2J1aWxkZXJzL3NyYy9zc3ItZGV2LXNlcnZlci9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7QUFFSCxPQUFPLEVBR0wsYUFBYSxFQUNiLHNCQUFzQixHQUN2QixNQUFNLDJCQUEyQixDQUFDO0FBQ25DLE9BQU8sRUFBaUIsSUFBSSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDM0QsT0FBTyxLQUFLLFdBQVcsTUFBTSxjQUFjLENBQUM7QUFDNUMsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDOUQsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLElBQUksV0FBVyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3BELE9BQU8sRUFBRSxLQUFLLEVBQWMsYUFBYSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3ZFLE9BQU8sRUFDTCxVQUFVLEVBQ1YsU0FBUyxFQUNULFFBQVEsRUFDUixZQUFZLEVBQ1osS0FBSyxFQUNMLFFBQVEsRUFDUixjQUFjLEVBQ2QsR0FBRyxFQUNILEtBQUssRUFDTCxTQUFTLEVBQ1QsU0FBUyxFQUNULEdBQUcsR0FDSixNQUFNLGdCQUFnQixDQUFDO0FBQ3hCLE9BQU8sS0FBSyxHQUFHLE1BQU0sS0FBSyxDQUFDO0FBRzNCLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRSwwQkFBMEIsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUUxRix3REFBd0Q7QUFDeEQsTUFBTSx1QkFBdUIsR0FBRztJQUM5QixxQkFBcUI7SUFDckIsMEZBQTBGO0NBQzNGLENBQUM7QUFPRixNQUFNLFVBQVUsT0FBTyxDQUNyQixPQUFtQyxFQUNuQyxPQUF1QjtJQUV2QixNQUFNLGFBQWEsR0FBRyxzQkFBc0IsQ0FB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O0lBRUQsT0FBTyxjQUFjLENBQUM7QUFDeEIsQ0FBQztBQUVELGVBQWUsYUFBYSxDQUE0QyxPQUFPLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1xuICBCdWlsZGVyQ29udGV4dCxcbiAgQnVpbGRlck91dHB1dCxcbiAgY3JlYXRlQnVpbGRlcixcbiAgdGFyZ2V0RnJvbVRhcmdldFN0cmluZyxcbn0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2FyY2hpdGVjdCc7XG5pbXBvcnQgeyBqc29uLCBsb2dnaW5nLCB0YWdzIH0gZnJvbSAnQGFuZ3VsYXItZGV2a2l0L2NvcmUnO1xuaW1wb3J0ICogYXMgYnJvd3NlclN5bmMgZnJvbSAnYnJvd3Nlci1zeW5jJztcbmltcG9ydCB7IGNyZWF0ZVByb3h5TWlkZGxld2FyZSB9IGZyb20gJ2h0dHAtcHJveHktbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBqb2luLCByZXNvbHZlIGFzIHBhdGhSZXNvbHZlIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBFTVBUWSwgT2JzZXJ2YWJsZSwgY29tYmluZUxhdGVzdCwgZnJvbSwgb2YsIHppcCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgY2F0Y2hFcnJvcixcbiAgY29uY2F0TWFwLFxuICBkZWJvdW5jZSxcbiAgZGVib3VuY2VUaW1lLFxuICBkZWxheSxcbiAgZmluYWxpemUsXG4gIGlnbm9yZUVsZW1lbnRzLFxuICBtYXAsXG4gIG1hcFRvLFxuICBzdGFydFdpdGgsXG4gIHN3aXRjaE1hcCxcbiAgdGFwLFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gJy4vc2NoZW1hJztcblxuaW1wb3J0IHsgZ2V0QXZhaWxhYmxlUG9ydCwgc3Bhd25Bc09ic2VydmFibGUsIHdhaXRVbnRpbFNlcnZlcklzTGlzdGVuaW5nIH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKiBMb2cgbWVzc2FnZXMgdG8gaWdub3JlIGFuZCBub3QgcmVseSB0byB0aGUgbG9nZ2VyICovXG5jb25zdCBJR05PUkVEX1NURE9VVF9NRVNTQUdFUyA9IFtcbiAgJ3NlcnZlciBsaXN0ZW5pbmcgb24nLFxuICAnQW5ndWxhciBpcyBydW5uaW5nIGluIGRldmVsb3BtZW50IG1vZGUuIENhbGwgZW5hYmxlUHJvZE1vZGUoKSB0byBlbmFibGUgcHJvZHVjdGlvbiBtb2RlLicsXG5dO1xuXG5leHBvcnQgdHlwZSBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3B0aW9ucyA9IFNjaGVtYSAmIGpzb24uSnNvbk9iamVjdDtcbmV4cG9ydCB0eXBlIFNTUkRldlNlcnZlckJ1aWxkZXJPdXRwdXQgPSBCdWlsZGVyT3V0cHV0ICYge1xuICBiYXNlVXJsPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGUoXG4gIG9wdGlvbnM6IFNTUkRldlNlcnZlckJ1aWxkZXJPcHRpb25zLFxuICBjb250ZXh0OiBCdWlsZGVyQ29udGV4dCxcbik6IE9ic2VydmFibGU8U1NSRGV2U2VydmVyQnVpbGRlck91dHB1dD4ge1xuICBjb25zdCBicm93c2VyVGFyZ2V0ID0gdGFyZ2V0RnJvbVRhcmdldFN0cmluZyhvcHRpb25zLmJyb3dzZXJUYXJnZXQpO1xuICBjb25zdCBzZXJ2ZXJUYXJnZXQgPSB0YXJnZXRGcm9tVGFyZ2V0U3RyaW5nKG9wdGlvbnMuc2VydmVyVGFyZ2V0KTtcbiAgY29uc3QgZ2V0QmFzZVVybCA9IChiczogYnJvd3NlclN5bmMuQnJvd3NlclN5bmNJbnN0YW5jZSkgPT5cbiAgICBgJHticy5nZXRPcHRpb24oJ3NjaGVtZScpfTovLyR7YnMuZ2V0T3B0aW9uKCdob3N0Jyl9OiR7YnMuZ2V0T3B0aW9uKCdwb3J0Jyl9YDtcbiAgY29uc3QgYnJvd3NlclRhcmdldFJ1biA9IGNvbnRleHQuc2NoZWR1bGVUYXJnZXQoYnJvd3NlclRhcmdldCwge1xuICAgIHNlcnZpY2VXb3JrZXI6IGZhbHNlLFxuICAgIHdhdGNoOiB0cnVlLFxuICAgIHByb2dyZXNzOiBvcHRpb25zLnByb2dyZXNzLFxuICAgIHZlcmJvc2U6IG9wdGlvbnMudmVyYm9zZSxcbiAgICAvLyBEaXNhYmxlIGJ1bmRsZSBidWRnZXRzIGFyZSB0aGVzZSBhcmUgbm90IG1lYW50IHRvIGJlIHVzZWQgd2l0aCBhIGRldi1zZXJ2ZXIgYXMgdGhpcyB3aWxsIGFkZCBleHRyYSBKYXZhU2NyaXB0IGZvciBsaXZlLXJlbG9hZGluZy5cbiAgICBidWRnZXRzOiBbXSxcbiAgfSk7XG5cbiAgY29uc3Qgc2VydmVyVGFyZ2V0UnVuID0gY29udGV4dC5zY2hlZHVsZVRhcmdldChzZXJ2ZXJUYXJnZXQsIHtcbiAgICB3YXRjaDogdHJ1ZSxcbiAgICBwcm9ncmVzczogb3B0aW9ucy5wcm9ncmVzcyxcbiAgICB2ZXJib3NlOiBvcHRpb25zLnZlcmJvc2UsXG4gIH0pO1xuXG4gIGNvbnN0IGJzSW5zdGFuY2UgPSBicm93c2VyU3luYy5jcmVhdGUoKTtcblxuICBjb250ZXh0LmxvZ2dlci5lcnJvcih0YWdzLnN0cmlwSW5kZW50c2BcbiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICBUaGlzIGlzIGEgc2ltcGxlIHNlcnZlciBmb3IgdXNlIGluIHRlc3Rpbmcgb3IgZGVidWdnaW5nIEFuZ3VsYXIgYXBwbGljYXRpb25zIGxvY2FsbHkuXG4gIEl0IGhhc24ndCBiZWVuIHJldmlld2VkIGZvciBzZWN1cml0eSBpc3N1ZXMuXG5cbiAgRE9OJ1QgVVNFIElUIEZPUiBQUk9EVUNUSU9OIVxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gYCk7XG5cbiAgcmV0dXJuIHppcChicm93c2VyVGFyZ2V0UnVuLCBzZXJ2ZXJUYXJnZXRSdW4sIGdldEF2YWlsYWJsZVBvcnQoKSkucGlwZShcbiAgICBzd2l0Y2hNYXAoKFticiwgc3IsIG5vZGVTZXJ2ZXJQb3J0XSkgPT4ge1xuICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoW2JyLm91dHB1dCwgc3Iub3V0cHV0XSkucGlwZShcbiAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgc28gdGhhdCBpZiBib3RoIHNlcnZlciBhbmQgYnJvd3NlciBlbWl0IGNsb3NlIHRvIGVhY2ggb3RoZXJcbiAgICAgICAgLy8gd2Ugb25seSBlbWl0IG9uY2UuIFRoaXMgdHlwaWNhbGx5IGhhcHBlbnMgb24gdGhlIGZpcnN0IGJ1aWxkLlxuICAgICAgICBkZWJvdW5jZVRpbWUoMTIwKSxcbiAgICAgICAgc3dpdGNoTWFwKChbYiwgc10pID0+IHtcbiAgICAgICAgICBpZiAoIXMuc3VjY2VzcyB8fCAhYi5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gb2YoW2IsIHNdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RhcnROb2RlU2VydmVyKHMsIG5vZGVTZXJ2ZXJQb3J0LCBjb250ZXh0LmxvZ2dlciwgISFvcHRpb25zLmluc3BlY3QpLnBpcGUoXG4gICAgICAgICAgICBtYXBUbyhbYiwgc10pLFxuICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmVycm9yKGBBIHNlcnZlciBlcnJvciBoYXMgb2NjdXJyZWQuXFxuJHttYXBFcnJvclRvTWVzc2FnZShlcnIpfWApO1xuXG4gICAgICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoXG4gICAgICAgICAgKFtiLCBzXSkgPT5cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGIuc3VjY2VzcyAmJiBzLnN1Y2Nlc3MsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGIuZXJyb3IgfHwgcy5lcnJvcixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbm9kZVNlcnZlclBvcnQsXG4gICAgICAgICAgICBdIGFzIFtTU1JEZXZTZXJ2ZXJCdWlsZGVyT3V0cHV0LCBudW1iZXJdLFxuICAgICAgICApLFxuICAgICAgICB0YXAoKFtidWlsZGVyT3V0cHV0XSkgPT4ge1xuICAgICAgICAgIGlmIChidWlsZGVyT3V0cHV0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmluZm8oJ1xcbkNvbXBpbGVkIHN1Y2Nlc3NmdWxseS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBkZWJvdW5jZSgoW2J1aWxkZXJPdXRwdXRdKSA9PlxuICAgICAgICAgIGJ1aWxkZXJPdXRwdXQuc3VjY2VzcyAmJiAhb3B0aW9ucy5pbnNwZWN0XG4gICAgICAgICAgICA/IHdhaXRVbnRpbFNlcnZlcklzTGlzdGVuaW5nKG5vZGVTZXJ2ZXJQb3J0KVxuICAgICAgICAgICAgOiBFTVBUWSxcbiAgICAgICAgKSxcbiAgICAgICAgZmluYWxpemUoKCkgPT4ge1xuICAgICAgICAgIHZvaWQgYnIuc3RvcCgpO1xuICAgICAgICAgIHZvaWQgc3Iuc3RvcCgpO1xuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSksXG4gICAgY29uY2F0TWFwKChbYnVpbGRlck91dHB1dCwgbm9kZVNlcnZlclBvcnRdKSA9PiB7XG4gICAgICBpZiAoIWJ1aWxkZXJPdXRwdXQuc3VjY2Vzcykge1xuICAgICAgICByZXR1cm4gb2YoYnVpbGRlck91dHB1dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChic0luc3RhbmNlLmFjdGl2ZSkge1xuICAgICAgICBic0luc3RhbmNlLnJlbG9hZCgpO1xuXG4gICAgICAgIHJldHVybiBvZihidWlsZGVyT3V0cHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcm9tKGluaXRCcm93c2VyU3luYyhic0luc3RhbmNlLCBub2RlU2VydmVyUG9ydCwgb3B0aW9ucywgY29udGV4dCkpLnBpcGUoXG4gICAgICAgICAgdGFwKChicykgPT4ge1xuICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmwoYnMpO1xuICAgICAgICAgICAgY29udGV4dC5sb2dnZXIuaW5mbyh0YWdzLm9uZUxpbmVgXG4gICAgICAgICAgICAgICAgKipcbiAgICAgICAgICAgICAgICBBbmd1bGFyIFVuaXZlcnNhbCBMaXZlIERldmVsb3BtZW50IFNlcnZlciBpcyBsaXN0ZW5pbmcgb24gJHtiYXNlVXJsfSxcbiAgICAgICAgICAgICAgICBvcGVuIHlvdXIgYnJvd3NlciBvbiAke2Jhc2VVcmx9XG4gICAgICAgICAgICAgICAgKipcbiAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbWFwVG8oYnVpbGRlck91dHB1dCksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSksXG4gICAgbWFwKFxuICAgICAgKGJ1aWxkZXJPdXRwdXQpID0+XG4gICAgICAgICh7XG4gICAgICAgICAgc3VjY2VzczogYnVpbGRlck91dHB1dC5zdWNjZXNzLFxuICAgICAgICAgIGVycm9yOiBidWlsZGVyT3V0cHV0LmVycm9yLFxuICAgICAgICAgIGJhc2VVcmw6IGJzSW5zdGFuY2UgJiYgZ2V0QmFzZVVybChic0luc3RhbmNlKSxcbiAgICAgICAgfSBhcyBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3V0cHV0KSxcbiAgICApLFxuICAgIGZpbmFsaXplKCgpID0+IHtcbiAgICAgIGlmIChic0luc3RhbmNlKSB7XG4gICAgICAgIGJzSW5zdGFuY2UuZXhpdCgpO1xuICAgICAgICBic0luc3RhbmNlLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBjYXRjaEVycm9yKChlcnJvcikgPT5cbiAgICAgIG9mKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBtYXBFcnJvclRvTWVzc2FnZShlcnJvciksXG4gICAgICB9KSxcbiAgICApLFxuICApO1xufVxuXG5mdW5jdGlvbiBzdGFydE5vZGVTZXJ2ZXIoXG4gIHNlcnZlck91dHB1dDogQnVpbGRlck91dHB1dCxcbiAgcG9ydDogbnVtYmVyLFxuICBsb2dnZXI6IGxvZ2dpbmcuTG9nZ2VyQXBpLFxuICBpbnNwZWN0TW9kZSA9IGZhbHNlLFxuKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gIGNvbnN0IG91dHB1dFBhdGggPSBzZXJ2ZXJPdXRwdXQub3V0cHV0UGF0aCBhcyBzdHJpbmc7XG4gIGNvbnN0IHBhdGggPSBqb2luKG91dHB1dFBhdGgsICdtYWluLmpzJyk7XG4gIGNvbnN0IGVudiA9IHsgLi4ucHJvY2Vzcy5lbnYsIFBPUlQ6ICcnICsgcG9ydCB9O1xuXG4gIGNvbnN0IGFyZ3MgPSBbJy0tZW5hYmxlLXNvdXJjZS1tYXBzJywgYFwiJHtwYXRofVwiYF07XG4gIGlmIChpbnNwZWN0TW9kZSkge1xuICAgIGFyZ3MudW5zaGlmdCgnLS1pbnNwZWN0LWJyaycpO1xuICB9XG5cbiAgcmV0dXJuIG9mKG51bGwpLnBpcGUoXG4gICAgZGVsYXkoMCksIC8vIEF2b2lkIEVBRERSSU5VU0UgZXJyb3Igc2luY2UgaXQgd2lsbCBjYXVzZSB0aGUga2lsbCBldmVudCB0byBiZSBmaW5pc2guXG4gICAgc3dpdGNoTWFwKCgpID0+IHNwYXduQXNPYnNlcnZhYmxlKCdub2RlJywgYXJncywgeyBlbnYsIHNoZWxsOiB0cnVlIH0pKSxcbiAgICB0YXAoKHsgc3RkZXJyLCBzdGRvdXQgfSkgPT4ge1xuICAgICAgaWYgKHN0ZGVycikge1xuICAgICAgICAvLyBTdHJpcCB0aGUgd2VicGFjayBzY2hlbWUgKHdlYnBhY2s6Ly8pIGZyb20gZXJyb3IgbG9nLlxuICAgICAgICBsb2dnZXIuZXJyb3Ioc3RkZXJyLnJlcGxhY2UoL3dlYnBhY2s6XFwvXFwvL2csICcuJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3Rkb3V0ICYmICFJR05PUkVEX1NURE9VVF9NRVNTQUdFUy5zb21lKCh4KSA9PiBzdGRvdXQuaW5jbHVkZXMoeCkpKSB7XG4gICAgICAgIGxvZ2dlci5pbmZvKHN0ZG91dCk7XG4gICAgICB9XG4gICAgfSksXG4gICAgaWdub3JlRWxlbWVudHMoKSxcbiAgICAvLyBFbWl0IGEgc2lnbmFsIGFmdGVyIHRoZSBwcm9jZXNzIGhhcyBiZWVuIHN0YXJ0ZWRcbiAgICBzdGFydFdpdGgodW5kZWZpbmVkKSxcbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdEJyb3dzZXJTeW5jKFxuICBicm93c2VyU3luY0luc3RhbmNlOiBicm93c2VyU3luYy5Ccm93c2VyU3luY0luc3RhbmNlLFxuICBub2RlU2VydmVyUG9ydDogbnVtYmVyLFxuICBvcHRpb25zOiBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3B0aW9ucyxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHQsXG4pOiBQcm9taXNlPGJyb3dzZXJTeW5jLkJyb3dzZXJTeW5jSW5zdGFuY2U+IHtcbiAgaWYgKGJyb3dzZXJTeW5jSW5zdGFuY2UuYWN0aXZlKSB7XG4gICAgcmV0dXJuIGJyb3dzZXJTeW5jSW5zdGFuY2U7XG4gIH1cblxuICBjb25zdCB7IHBvcnQ6IGJyb3dzZXJTeW5jUG9ydCwgb3BlbiwgaG9zdCwgcHVibGljSG9zdCwgcHJveHlDb25maWcgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJzUG9ydCA9IGJyb3dzZXJTeW5jUG9ydCB8fCAoYXdhaXQgZ2V0QXZhaWxhYmxlUG9ydCgpKTtcbiAgY29uc3QgYnNPcHRpb25zOiBicm93c2VyU3luYy5PcHRpb25zID0ge1xuICAgIHByb3h5OiB7XG4gICAgICB0YXJnZXQ6IGBsb2NhbGhvc3Q6JHtub2RlU2VydmVyUG9ydH1gLFxuICAgICAgcHJveHlPcHRpb25zOiB7XG4gICAgICAgIHhmd2Q6IHRydWUsXG4gICAgICB9LFxuICAgICAgcHJveHlSZXM6IFtcbiAgICAgICAgKHByb3h5UmVzKSA9PiB7XG4gICAgICAgICAgaWYgKCdoZWFkZXJzJyBpbiBwcm94eVJlcykge1xuICAgICAgICAgICAgcHJveHlSZXMuaGVhZGVyc1snY2FjaGUtY29udHJvbCddID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICAvLyBwcm94eU9wdGlvbnMgaXMgbm90IGluIHRoZSB0eXBpbmdzXG4gICAgfSBhcyBicm93c2VyU3luYy5Qcm94eU9wdGlvbnMgJiB7IHByb3h5T3B0aW9uczogeyB4ZndkOiBib29sZWFuIH0gfSxcbiAgICBob3N0LFxuICAgIHBvcnQ6IGJzUG9ydCxcbiAgICB1aTogZmFsc2UsXG4gICAgc2VydmVyOiBmYWxzZSxcbiAgICBub3RpZnk6IGZhbHNlLFxuICAgIGdob3N0TW9kZTogZmFsc2UsXG4gICAgbG9nTGV2ZWw6IG9wdGlvbnMudmVyYm9zZSA/ICdkZWJ1ZycgOiAnc2lsZW50JyxcbiAgICBvcGVuLFxuICAgIGh0dHBzOiBnZXRTc2xDb25maWcoY29udGV4dC53b3Jrc3BhY2VSb290LCBvcHRpb25zKSxcbiAgfTtcblxuICBjb25zdCBwdWJsaWNIb3N0Tm9ybWFsaXplZCA9XG4gICAgcHVibGljSG9zdCAmJiBwdWJsaWNIb3N0LmVuZHNXaXRoKCcvJylcbiAgICAgID8gcHVibGljSG9zdC5zdWJzdHJpbmcoMCwgcHVibGljSG9zdC5sZW5ndGggLSAxKVxuICAgICAgOiBwdWJsaWNIb3N0O1xuXG4gIGlmIChwdWJsaWNIb3N0Tm9ybWFsaXplZCkge1xuICAgIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0LCBwYXRobmFtZSB9ID0gdXJsLnBhcnNlKHB1YmxpY0hvc3ROb3JtYWxpemVkKTtcbiAgICBjb25zdCBkZWZhdWx0U29ja2V0SW9QYXRoID0gJy9icm93c2VyLXN5bmMvc29ja2V0LmlvJztcbiAgICBjb25zdCBkZWZhdWx0TmFtZXNwYWNlID0gJy9icm93c2VyLXN5bmMnO1xuICAgIGNvbnN0IGhhc1BhdGhuYW1lID0gISEocGF0aG5hbWUgJiYgcGF0aG5hbWUgIT09ICcvJyk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gaGFzUGF0aG5hbWUgPyBwYXRobmFtZSArIGRlZmF1bHROYW1lc3BhY2UgOiBkZWZhdWx0TmFtZXNwYWNlO1xuICAgIGNvbnN0IHBhdGggPSBoYXNQYXRobmFtZSA/IHBhdGhuYW1lICsgZGVmYXVsdFNvY2tldElvUGF0aCA6IGRlZmF1bHRTb2NrZXRJb1BhdGg7XG5cbiAgICBic09wdGlvbnMuc29ja2V0ID0ge1xuICAgICAgbmFtZXNwYWNlLFxuICAgICAgcGF0aCxcbiAgICAgIGRvbWFpbjogdXJsLmZvcm1hdCh7XG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcG9ydCxcbiAgICAgIH0pLFxuICAgIH07XG5cbiAgICAvLyBXaGVuIGhhdmluZyBhIHBhdGhuYW1lIHdlIGFsc28gbmVlZCB0byBjcmVhdGUgYSByZXZlcnNlIHByb3h5IGJlY2F1c2Ugc29ja2V0LmlvXG4gICAgLy8gd2lsbCBiZSBsaXN0ZW5pbmcgb246ICdodHRwOi8vbG9jYWxob3N0OjQyMDAvc3NyL2Jyb3dzZXItc3luYy9zb2NrZXQuaW8nXG4gICAgLy8gSG93ZXZlciB1c2VycyB3aWxsIHR5cGljYWxseSBoYXZlIGEgcmV2ZXJzZSBwcm94eSB0aGF0IHdpbGwgcmVkaXJlY3QgYWxsIG1hdGNoaW5nIHJlcXVlc3RzXG4gICAgLy8gZXg6IGh0dHA6Ly90ZXN0aW5naG9zdC5jb20vc3NyIC0+IGh0dHA6Ly9sb2NhbGhvc3Q6NDIwMCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIDQwNC5cbiAgICBpZiAoaGFzUGF0aG5hbWUpIHtcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHNsYXNoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgKGJzT3B0aW9ucy5zY3JpcHRQYXRoID0gKHApID0+IHAuc3Vic3RyaW5nKDEpKSxcbiAgICAgICAgKGJzT3B0aW9ucy5taWRkbGV3YXJlID0gW1xuICAgICAgICAgIGNyZWF0ZVByb3h5TWlkZGxld2FyZShkZWZhdWx0U29ja2V0SW9QYXRoLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IHVybC5mb3JtYXQoe1xuICAgICAgICAgICAgICBwcm90b2NvbDogJ2h0dHAnLFxuICAgICAgICAgICAgICBob3N0bmFtZTogaG9zdCxcbiAgICAgICAgICAgICAgcG9ydDogYnNQb3J0LFxuICAgICAgICAgICAgICBwYXRobmFtZTogcGF0aCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd3M6IHRydWUsXG4gICAgICAgICAgICBsb2dMZXZlbDogJ3NpbGVudCcsXG4gICAgICAgICAgfSkgYXMgYW55LFxuICAgICAgICBdKTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJveHlDb25maWcpIHtcbiAgICBpZiAoIWJzT3B0aW9ucy5taWRkbGV3YXJlKSB7XG4gICAgICBic09wdGlvbnMubWlkZGxld2FyZSA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnNPcHRpb25zLm1pZGRsZXdhcmUpKSB7XG4gICAgICBic09wdGlvbnMubWlkZGxld2FyZSA9IFtic09wdGlvbnMubWlkZGxld2FyZV07XG4gICAgfVxuXG4gICAgYnNPcHRpb25zLm1pZGRsZXdhcmUgPSBbXG4gICAgICAuLi5ic09wdGlvbnMubWlkZGxld2FyZSxcbiAgICAgIC4uLmdldFByb3h5Q29uZmlnKGNvbnRleHQud29ya3NwYWNlUm9vdCwgcHJveHlDb25maWcpLFxuICAgIF07XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGJyb3dzZXJTeW5jSW5zdGFuY2UuaW5pdChic09wdGlvbnMsIChlcnJvciwgYnMpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShicyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYXBFcnJvclRvTWVzc2FnZShlcnJvcjogdW5rbm93bik6IHN0cmluZyB7XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U3NsQ29uZmlnKFxuICByb290OiBzdHJpbmcsXG4gIG9wdGlvbnM6IFNTUkRldlNlcnZlckJ1aWxkZXJPcHRpb25zLFxuKTogYnJvd3NlclN5bmMuSHR0cHNPcHRpb25zIHwgdW5kZWZpbmVkIHwgYm9vbGVhbiB7XG4gIGNvbnN0IHsgc3NsLCBzc2xDZXJ0LCBzc2xLZXkgfSA9IG9wdGlvbnM7XG4gIGlmIChzc2wgJiYgc3NsQ2VydCAmJiBzc2xLZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBwYXRoUmVzb2x2ZShyb290LCBzc2xLZXkpLFxuICAgICAgY2VydDogcGF0aFJlc29sdmUocm9vdCwgc3NsQ2VydCksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzc2w7XG59XG5cbmZ1bmN0aW9uIGdldFByb3h5Q29uZmlnKHJvb3Q6IHN0cmluZywgcHJveHlDb25maWc6IHN0cmluZyk6IGJyb3dzZXJTeW5jLk1pZGRsZXdhcmVIYW5kbGVyW10ge1xuICBjb25zdCBwcm94eVBhdGggPSBwYXRoUmVzb2x2ZShyb290LCBwcm94eUNvbmZpZyk7XG4gIGxldCBwcm94eVNldHRpbmdzOiBhbnk7XG4gIHRyeSB7XG4gICAgcHJveHlTZXR0aW5ncyA9IHJlcXVpcmUocHJveHlQYXRoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gJ01PRFVMRV9OT1RfRk9VTkQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3h5IGNvbmZpZyBmaWxlICR7cHJveHlQYXRofSBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGNvbnN0IHByb3hpZXMgPSBBcnJheS5pc0FycmF5KHByb3h5U2V0dGluZ3MpID8gcHJveHlTZXR0aW5ncyA6IFtwcm94eVNldHRpbmdzXTtcbiAgY29uc3QgY3JlYXRlZFByb3hpZXMgPSBbXTtcblxuICBmb3IgKGNvbnN0IHByb3h5IG9mIHByb3hpZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGNvbnRleHRdIG9mIE9iamVjdC5lbnRyaWVzKHByb3h5KSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNyZWF0ZWRQcm94aWVzLnB1c2goXG4gICAgICAgICAgY3JlYXRlUHJveHlNaWRkbGV3YXJlKFxuICAgICAgICAgICAga2V5LnJlcGxhY2UoL15cXCokLywgJyoqJykucmVwbGFjZSgvXFwvXFwqJC8sICcnKSxcbiAgICAgICAgICAgIGNvbnRleHQgYXMgYW55LFxuICAgICAgICAgICkgYXMgYnJvd3NlclN5bmMuTWlkZGxld2FyZUhhbmRsZXIsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVkUHJveGllcy5wdXNoKFxuICAgICAgICAgIGNyZWF0ZVByb3h5TWlkZGxld2FyZShrZXksIGNvbnRleHQgYXMgYW55KSBhcyBicm93c2VyU3luYy5NaWRkbGV3YXJlSGFuZGxlcixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3JlYXRlZFByb3hpZXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJ1aWxkZXI8U1NSRGV2U2VydmVyQnVpbGRlck9wdGlvbnMsIEJ1aWxkZXJPdXRwdXQ+KGV4ZWN1dGUpO1xuIl19